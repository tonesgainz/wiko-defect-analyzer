AWSTemplateFormatVersion: '2010-09-09'
Description: 'Wiko Defect Analyzer - AWS Bedrock Backend Infrastructure'

Parameters:
  Environment:
    Type: String
    Default: prod
    AllowedValues:
      - dev
      - staging
      - prod
    Description: Environment name

Resources:
  # ============================================================
  # S3 Bucket for Inspection Images
  # ============================================================
  ImageBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'wiko-defect-analyzer-images-${AWS::AccountId}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldImages
            Status: Enabled
            ExpirationInDays: 90
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
              - PUT
              - POST
            AllowedOrigins:
              - '*'
            MaxAge: 3600
      Tags:
        - Key: Project
          Value: WikoDefectAnalyzer
        - Key: Environment
          Value: !Ref Environment

  # ============================================================
  # DynamoDB Table for Defect Records
  # ============================================================
  DefectsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'wiko-defect-analyzer-defects'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: defect_id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
        - AttributeName: facility
          AttributeType: S
      KeySchema:
        - AttributeName: defect_id
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: facility-timestamp-index
          KeySchema:
            - AttributeName: facility
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Project
          Value: WikoDefectAnalyzer
        - Key: Environment
          Value: !Ref Environment

  # ============================================================
  # IAM Role for Lambda Function
  # ============================================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'wiko-defect-analyzer-lambda-role-${AWS::Region}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-5-sonnet-20241022-v2:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-5-sonnet-20240620-v1:0'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub '${ImageBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !GetAtt ImageBucket.Arn
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt DefectsTable.Arn
                  - !Sub '${DefectsTable.Arn}/index/*'

  # ============================================================
  # Lambda Function - Defect Analysis
  # ============================================================
  AnalyzeLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'wiko-defect-analyzer-analyze'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 90
      MemorySize: 512
      Environment:
        Variables:
          IMAGE_BUCKET: !Ref ImageBucket
          DEFECTS_TABLE: !Ref DefectsTable
          BEDROCK_MODEL_ID: 'anthropic.claude-3-5-sonnet-20241022-v2:0'
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import base64
          import os
          import uuid
          from datetime import datetime
          from decimal import Decimal

          bedrock = boto3.client('bedrock-runtime', region_name=os.environ['AWS_REGION'])
          s3 = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['DEFECTS_TABLE'])

          DEFECT_TYPES = {
              "rust_spot": "Surface oxidation (CRITICAL - indicates vacuum quench failure)",
              "blade_scratch": "Surface scratches on blade",
              "edge_irregularity": "Uneven or wavy cutting edge",
              "handle_crack": "Cracks in handle material",
              "weld_defect": "Issues with bolster welding",
              "polish_defect": "Uneven or missing polish",
              "blade_chip": "Missing material from blade edge",
              "handle_discoloration": "Color inconsistency in handle",
              "dimensional_error": "Size/shape out of specification",
              "assembly_misalignment": "Components not properly aligned",
              "surface_contamination": "Foreign material on surface"
          }

          PRODUCTION_STAGES = {
              "blade_stamp": "Blade Stamping",
              "bolster_welding": "Bolster Welding",
              "back_edge_polishing": "Back Edge Polishing",
              "taper_grinding": "Taper Grinding",
              "heat_treatment": "Heat Treatment",
              "vacuum_quench": "Vacuum Quench",
              "handle_injection": "Handle Injection",
              "rivet_assembly": "Rivet Assembly",
              "handle_polishing": "Handle Polishing",
              "blade_glazing": "Blade Glazing",
              "cutting_edge_honing": "Cutting Edge Honing",
              "logo_print": "Logo Print"
          }

          def lambda_handler(event, context):
              try:
                  # Parse request body
                  body = json.loads(event.get('body', '{}'))
                  image_base64 = body.get('image')
                  product_sku = body.get('product_sku', 'UNKNOWN')
                  facility = body.get('facility', 'UNKNOWN')

                  if not image_base64:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Headers': 'Content-Type',
                              'Access-Control-Allow-Methods': 'POST, OPTIONS'
                          },
                          'body': json.dumps({'error': 'Missing image data'})
                      }

                  # Generate IDs
                  defect_id = str(uuid.uuid4())
                  timestamp = int(datetime.utcnow().timestamp())
                  image_key = 'inspections/%s/%s/%s.jpg' % (facility, product_sku, defect_id)

                  # Store image in S3
                  image_data = base64.b64decode(image_base64.split(',')[1] if ',' in image_base64 else image_base64)
                  s3.put_object(
                      Bucket=os.environ['IMAGE_BUCKET'],
                      Key=image_key,
                      Body=image_data,
                      ContentType='image/jpeg'
                  )

                  # Analyze with Bedrock Claude
                  prompt = 'You are an expert quality inspector for Wiko Cutlery, a premium knife manufacturer.\n\n'
                  prompt += 'Analyze this product image for manufacturing defects.\n\n'
                  prompt += 'Product SKU: %s\n' % product_sku
                  prompt += 'Facility: %s\n\n' % facility
                  prompt += 'Known defect types:\n%s\n\n' % json.dumps(DEFECT_TYPES, indent=2)
                  prompt += 'Production stages:\n%s\n\n' % json.dumps(PRODUCTION_STAGES, indent=2)
                  prompt += 'Provide your analysis in this JSON format:\n'
                  prompt += '{\n'
                  prompt += '  "has_defect": true/false,\n'
                  prompt += '  "defect_type": "one of the defect types above or none",\n'
                  prompt += '  "severity": "critical/major/minor/cosmetic",\n'
                  prompt += '  "probable_stage": "manufacturing stage where defect likely occurred",\n'
                  prompt += '  "confidence": 0.0-1.0,\n'
                  prompt += '  "description": "detailed description of the defect",\n'
                  prompt += '  "root_cause": "likely root cause analysis",\n'
                  prompt += '  "recommendation": "recommended action"\n'
                  prompt += '}\n\n'
                  prompt += 'Be thorough and professional in your analysis.'

                  # Call Bedrock
                  response = bedrock.invoke_model(
                      modelId=os.environ['BEDROCK_MODEL_ID'],
                      contentType='application/json',
                      accept='application/json',
                      body=json.dumps({
                          'anthropic_version': 'bedrock-2023-05-31',
                          'max_tokens': 4096,
                          'messages': [
                              {
                                  'role': 'user',
                                  'content': [
                                      {
                                          'type': 'image',
                                          'source': {
                                              'type': 'base64',
                                              'media_type': 'image/jpeg',
                                              'data': image_base64.split(',')[1] if ',' in image_base64 else image_base64
                                          }
                                      },
                                      {
                                          'type': 'text',
                                          'text': prompt
                                      }
                                  ]
                              }
                          ]
                      })
                  )

                  # Parse Bedrock response
                  response_body = json.loads(response['body'].read())
                  content_text = response_body['content'][0]['text']

                  # Extract JSON from response
                  try:
                      # Try to find JSON in the response
                      json_start = content_text.find('{')
                      json_end = content_text.rfind('}') + 1
                      analysis = json.loads(content_text[json_start:json_end])
                  except:
                      # Fallback if JSON parsing fails
                      analysis = {
                          'has_defect': False,
                          'defect_type': 'none',
                          'severity': 'cosmetic',
                          'confidence': 0.5,
                          'description': content_text,
                          'root_cause': 'Unable to parse structured response',
                          'recommendation': 'Manual review required'
                      }

                  # Store in DynamoDB
                  item = {
                      'defect_id': defect_id,
                      'timestamp': timestamp,
                      'facility': facility,
                      'product_sku': product_sku,
                      'image_url': 's3://%s/%s' % (os.environ['IMAGE_BUCKET'], image_key),
                      'analysis': analysis,
                      'created_at': datetime.utcnow().isoformat()
                  }

                  # Convert floats to Decimal for DynamoDB
                  item = json.loads(json.dumps(item), parse_float=Decimal)
                  table.put_item(Item=item)

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'POST, OPTIONS'
                      },
                      'body': json.dumps({
                          'defect_id': defect_id,
                          'timestamp': timestamp,
                          'analysis': analysis
                      })
                  }

              except Exception as e:
                  print('Error: %s' % str(e))
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'POST, OPTIONS'
                      },
                      'body': json.dumps({'error': str(e)})
                  }
      Tags:
        - Key: Project
          Value: WikoDefectAnalyzer
        - Key: Environment
          Value: !Ref Environment

  # ============================================================
  # Lambda Function - Get Defects
  # ============================================================
  GetDefectsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'wiko-defect-analyzer-get-defects'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          DEFECTS_TABLE: !Ref DefectsTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['DEFECTS_TABLE'])

          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              try:
                  params = event.get('queryStringParameters', {}) or {}
                  facility = params.get('facility')
                  limit = int(params.get('limit', 50))

                  if facility:
                      response = table.query(
                          IndexName='facility-timestamp-index',
                          KeyConditionExpression='facility = :facility',
                          ExpressionAttributeValues={':facility': facility},
                          Limit=limit,
                          ScanIndexForward=False
                      )
                  else:
                      response = table.scan(Limit=limit)

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'GET, OPTIONS'
                      },
                      'body': json.dumps({
                          'defects': response['Items'],
                          'count': len(response['Items'])
                      }, cls=DecimalEncoder)
                  }

              except Exception as e:
                  print('Error: %s' % str(e))
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'GET, OPTIONS'
                      },
                      'body': json.dumps({'error': str(e)})
                  }

  # ============================================================
  # Lambda Function - Get Statistics
  # ============================================================
  GetStatsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'wiko-defect-analyzer-stats'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          DEFECTS_TABLE: !Ref DefectsTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from decimal import Decimal
          from collections import Counter

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['DEFECTS_TABLE'])

          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              try:
                  response = table.scan()
                  items = response['Items']

                  total_inspections = len(items)
                  total_defects = sum(1 for item in items if item.get('analysis', {}).get('has_defect'))
                  defect_rate = (total_defects / total_inspections * 100) if total_inspections > 0 else 0

                  defect_types = Counter()
                  severities = Counter()

                  for item in items:
                      analysis = item.get('analysis', {})
                      if analysis.get('has_defect'):
                          defect_types[analysis.get('defect_type', 'unknown')] += 1
                          severities[analysis.get('severity', 'unknown')] += 1

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'GET, OPTIONS'
                      },
                      'body': json.dumps({
                          'total_inspections': total_inspections,
                          'total_defects': total_defects,
                          'defect_rate': round(defect_rate, 2),
                          'by_type': dict(defect_types),
                          'by_severity': dict(severities)
                      }, cls=DecimalEncoder)
                  }

              except Exception as e:
                  print('Error: %s' % str(e))
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': 'Content-Type',
                          'Access-Control-Allow-Methods': 'GET, OPTIONS'
                      },
                      'body': json.dumps({'error': str(e)})
                  }

  # ============================================================
  # API Gateway
  # ============================================================
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'wiko-defect-analyzer-api'
      Description: 'Wiko Defect Analyzer API'
      EndpointConfiguration:
        Types:
          - REGIONAL

  # API Resources
  ApiResourceV1:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: api

  ApiResourceVersion:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResourceV1
      PathPart: v1

  ApiResourceAnalyze:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResourceVersion
      PathPart: analyze

  ApiResourceDefects:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResourceVersion
      PathPart: defects

  ApiResourceStats:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiResourceVersion
      PathPart: stats

  ApiResourceHealth:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: health

  # POST /api/v1/analyze
  AnalyzeMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceAnalyze
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AnalyzeLambdaFunction.Arn}/invocations'

  AnalyzeOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceAnalyze
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # GET /api/v1/defects
  DefectsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceDefects
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetDefectsLambdaFunction.Arn}/invocations'

  DefectsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceDefects
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # GET /api/v1/stats
  StatsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceStats
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetStatsLambdaFunction.Arn}/invocations'

  StatsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceStats
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # GET /health
  HealthMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiResourceHealth
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: '{"status": "healthy", "timestamp": "$context.requestTime"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200

  # API Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - AnalyzeMethod
      - DefectsMethod
      - StatsMethod
      - HealthMethod
    Properties:
      RestApiId: !Ref ApiGateway

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref ApiGateway
      DeploymentId: !Ref ApiDeployment
      StageName: !Ref Environment
      Description: !Sub '${Environment} stage'

  # Lambda Permissions for API Gateway
  AnalyzeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AnalyzeLambdaFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  GetDefectsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetDefectsLambdaFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  GetStatsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetStatsLambdaFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

Outputs:
  ApiEndpoint:
    Description: 'API Gateway endpoint URL'
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  ImageBucketName:
    Description: 'S3 bucket for inspection images'
    Value: !Ref ImageBucket
    Export:
      Name: !Sub '${AWS::StackName}-ImageBucket'

  DefectsTableName:
    Description: 'DynamoDB table for defect records'
    Value: !Ref DefectsTable
    Export:
      Name: !Sub '${AWS::StackName}-DefectsTable'

  AnalyzeLambdaArn:
    Description: 'ARN of the analyze Lambda function'
    Value: !GetAtt AnalyzeLambdaFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-AnalyzeLambdaArn'
